<html>
    <head>
        <meta charset="utf-8">
        <title>Services Metadata</title>
        <link rel="stylesheet" href="saskan_style.css">
    </head>

<body>
    <div class="menu">
        <a href="./app_help.html">Home</a> &bull;
        <a href="./app_arch.html">Application</a> &bull;
        <a href="./svc_arch.html">Services</a> &bull;
        <a href="./data_arch.html">Data</a>
    </div>
    <div class="page">
        <h1><a name="svc_design">Services Metadata</a></h3>

        <p>The experimental design intention is to make the system flexible and anti-fragile. By defining all services as metadata, it is hoped that modifications can occur largely by observing and testing behaviors which can be added, tweaked, removed, refactored without a great deal of re-compling/re-deploying program code.

        <p>Services metadata is implemented in the first instance as JSON files held in the "config" namespaces and organized into the following categories:
            <ul>
                <li><b>Controllers</b> - A Controller manages a Service Namespace. Metadata about the Topics it handles, what Brokers it uses.
                <li><b>Brokers</b> - What types of Message Brokers are available and their characteristics, such as what kind of Channels they serve.
                <li><b>Channels</b> - What types of Response Channels are available and their characteristics.
                <li><b>Topics</b> - Metadata concerning logical categories of messages, typically organized around semantic or functional themes.
                <li><b>Message Structures</b> - Generic and specific message record structures. Message hierarchies under each topic.
                <li><b>Requests</b> - For a given Topic, what Request messages are defined, their rules and characteristics.
                <li><b>Replies</b> - For a given Request, what Reply messages are defined, their rules and characteristics.
            </ul>


        <p>By using an ontology as the foundation, it is further considered that the design of both the services architecture and game content could be developed and changed in a manner that is flexible, controlled and obvious. To this end, there is the idea, for example, that SQL code (once a SQL engine is added) could be auto-generated as much as possible based on interpretation of behavioral use case patterns. (This is not yet implemented.) Or similarly that other types of code could be auto-generated, perhaps with the help of an AI engine of some kind.

                <p> &nbsp;</p>
        <p> &nbsp;</p>
    </div>
</body>
</html>
