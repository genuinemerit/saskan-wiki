# Application Services, Channels, Topics and Messages

## Overview

A design goal is to make the application components flexible and robust by employing something like a micro-services architecture. The application is divided into a number of loosely coupled services, each of which is responsible for a specific task. The services communicate with each other using a message-based protocol. The services are implemented in Python, using the asyncio library. The services are designed to be modular and extensible.
 The services are intended to be able to run on different platforms, including Windows, Linux, and Mac OS X. However, the current development approach is being done excluusively on Ubuntu Linux.
 Furthermore, not every functional component of the application needs to be implemented as a service. For example, the GUI's are implemented as a single process using the pygame event loop, and they are not intended to be a service. The GUI's are clients of the services; they communicates with services using the message-based protocols.

## Service Components

There are 3 main feature sets of the services software components:
 * Server or Control components, including the service controller, channels and brokers
 * Request components
 * Response components


Software **components** (python classes) providing those features directly call shared procedural and functional component methods (also implemented as Python classes). These include file IO and wiretap (logging and monitoring) methods, as well as a class for generating and sequencing messaging payloads.
 A given collection of service components handles one or more semantic categories referred to as **topics**. Examples of application topics:
 * Example 1
 * Example 2
 * Example 3


Service **controller** components are the "traffic cops" for a set of message topics.
 Service **request messages** (senders), generated from application GUIs or other functional layers, are implemented with a type of consumer in mind. Within a topic, then, multiple **request message types** may be available, each associated with one or type of response message crafted for a particular style of message consumer. These message-consumer styles include:
 * Transactional (one-to-one) client
 *Example*: Player requests to move a token on a map to specified target
* Polling Consumer (one-to-many) client
 *Example*: Player sends a notice to team mates who've subscribed to them
* Event-Driver Consumer (one-to-many) client
 *Example*: Game event generator sends an earthquake rumble to all avatars in an area


Service **response messages** are generated by the responder components (listeners) in reply to a request message. They apply appropriate functional logic to satisfy the request, typically interacting with the shared game data namespaces. The response package is posted to a **response message store** and picked up for handling by the service control component.
 Topics handled by a collection of related service components use one or more **broker** styles to communicate between request and response components. These distinct broker types are referred to as **channels**. Channel types handle the implementation various request styles. They include:
 * Request/Reply
 * Pub/Sub
 * Recipient List
 * Datatype Channel
 * Invalid Message


See the [Services Architecture page](./svc_arch.html) for more details.




